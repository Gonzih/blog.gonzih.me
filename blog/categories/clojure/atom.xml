<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: clojure | Max Gonzih]]></title>
  <link href="http://blog.gonzih.me/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://blog.gonzih.me/"/>
  <updated>2016-06-21T09:56:25+00:00</updated>
  <id>http://blog.gonzih.me/</id>
  <author>
    <name><![CDATA[Max Gonzih ]]></name>
    <email><![CDATA[gonzih@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Nvim terminal + ClojureScript and figwheel]]></title>
    <link href="http://blog.gonzih.me/blog/2015/06/15/nvim-terminal-plus-clojurescript-and-figwheel/"/>
    <updated>2015-06-15T19:37:00+00:00</updated>
    <id>http://blog.gonzih.me/blog/2015/06/15/nvim-terminal-plus-clojurescript-and-figwheel</id>
    <content type="html"><![CDATA[<p>This is a small post on how to improve your ClojureScript development flow in NeoVim using its terminal feature.</p>

<!--more-->


<p><a href="http://neovim.io/">NeoVim</a> nowadays is almost fully compatible with vim.
It is able to reuse my <a href="https://github.com/Gonzih/.vim/blob/master/vimrc">.vimrc</a> file without any issues.
And recently it got proper terminal emulator built-in.
So how about reusing it for ClojureScript development?</p>

<p>If you are lazy (like I am) and don't want to setup piggieback support
for fireplace.vim or don't feel like tmux integration is good enough
this solution should be your new starting point.</p>

<p>Just open some clojure[script] file and create second split.
Open terminal using <code>:terminal</code> command.</p>

<p>Here are some keybindings that will help you to send code from
your clojure buffer to the terminal buffer.</p>

<p><code>vim
if has("nvim")
  " Open terminal and run lein figwheel
  nmap &lt;Leader&gt;term &lt;C-w&gt;v:terminal&lt;CR&gt;lein figwheel&lt;CR&gt;&lt;C-\&gt;&lt;C-n&gt;&lt;C-w&gt;p
  " Evaluate anything from the visual mode in the next window
  vmap &lt;buffer&gt; ,e y&lt;C-w&gt;wpi&lt;CR&gt;&lt;C-\&gt;&lt;C-n&gt;&lt;C-w&gt;p
  " Evaluate outer most form
  nmap &lt;buffer&gt; ,e ^v%,e
  " Evaluate buffer"
  nmap &lt;buffer&gt; ,b ggVG,e
endif
</code></p>

<p>Hey! Now you can finally stop looking at the emacs land!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ServerSide rendering of Reagent components]]></title>
    <link href="http://blog.gonzih.me/blog/2015/02/16/serverside-rendering-of-reagent-components/"/>
    <updated>2015-02-16T10:12:00+00:00</updated>
    <id>http://blog.gonzih.me/blog/2015/02/16/serverside-rendering-of-reagent-components</id>
    <content type="html"><![CDATA[<p>Great thing about React is that you can write what people nowadays call "isomorphic JavaScript".
In this post we will not discuss how wrong this term is in many ways,
but instead we will focus on how to achieve similar results in your ClojureScript code using Reagent library.</p>

<!--more-->


<p>In my experience simplest optimization to run in some js engine on server side is whitespace.
It does not do any renaming/restructuring of your code but eliminates need to take care of dependencies loading.
So our compiler configuration should look something like that:</p>

<p>```clojure
{:id "server-side"
 :source-paths ["src"]
 :compiler {:output-to "resources/public/javascripts/server-side.js"</p>

<pre><code>        :output-dir "resources/public/javascripts/out-server-side"
        :preamble ["meta-inf/resources/webjars/react/0.12.1/react-with-addons.min.js"]
        :pretty-print false
        :warnings true
        :optimizations :whitespace}}
</code></pre>

<p>```</p>

<p>Next step is to make sure that all functions that use browser specific stuff like document/window are moved in to react lifecycle methods:</p>

<p>```clojure
(def main-component
  (with-meta</p>

<pre><code>(fn [] ...)
{:component-did-mount (comp init-my-scroll-handler!
                            also-init-my-go-loop!)}))
</code></pre>

<p>```</p>

<p>Next let's create function that will do some rendering to the string.
I like to keep this function in a component specific ns just for convenience.</p>

<p><code>clojure
(def ^:export render-me-to-s [initial-state]
  (reset! my-main-state (js-&gt;clj initial-state))
  ; Render component to markup without reactid
  (reagent.core/render-to-static-markup [main-component])
  ; Or render component to ready to-go react markup
  (reagent.core/render-to-string [main-component]))
</code></p>

<p>Now server side bootstrapping, most of this code was taken from <a href="https://github.com/reactjs/react-rails">react-rails plugin</a>.</p>

<p>First of all react expects to have global or window objects in your js engine:</p>

<p>```javascript setup.js
var global = global || this;
var self = self || this;
var window = window || this;
var console = global.console || {};
['error', 'log', 'info', 'warn'].forEach(function (fn) {
  if (!(fn in console)) {</p>

<pre><code>console[fn] = function () {};
</code></pre>

<p>  }
});
```</p>

<p>Now let's try and use all this in our code (for now in Ruby):</p>

<p><code>ruby
cxt = V8::Context.new
cxt.load('setup.js')
cxt.load('resources/public/javascripts/server-side.js')
html = cxt.eval("my.amazing_component.ns.render_me_to_s(#{init_state.to_json})")
</code></p>

<p>And that's it. As a way to pass data from ruby to clojurescript json works fine.
Sometimes you might want to use <code>ActionController::Base.helpers.j</code> helper that will
escape your data for usage inside json, but most of the time you should be alright without it.</p>

<p>If you have issues with core.async there are 2 ways to solve it.
I personally prefer to move core.async initialization into some lifecycle method.
Another solution is to implement setTimeout function like that in your <code>setup.js</code> snippet:</p>

<p>```javascript
goog.global.setTimeout = function(cb, t) {</p>

<pre><code>cb();
</code></pre>

<p>}
```</p>

<p>Now frontend part. First let's in-line generated html in to the container:</p>

<p>```erb</p>

<div id="content"><%= html %></div>


<p>```</p>

<p>Then let's write function that will render our component on frontend:</p>

<p>```clojure
(def ^:export mount-me [initial-state]
  (reset! my-main-state (js->clj initial-state))
  (reagent.core/render [main-component]</p>

<pre><code>                   (js/document.getElementById "content")))
</code></pre>

<p>```</p>

<p>As far as I understand react should reuse your markup on frontend and just attach new handlers to it.
Am I wrong on this one? Don't know yet.</p>

<p>Inline javascript that you should use on frontend looks like that:</p>

<p>```erb</p>

<script>
my.amazing_component.ns.mount_me(<%= init_state.to_json %>)
</script>


<p>```</p>

<h3>Nashorn example (result of my experiments in the REPL)</h3>

<p>```clojure
(import '[javax.script ScriptEngineManager])
(def nashorn (.getEngineByName (ScriptEngineManager.) "nashorn"))</p>

<p>; Same as in ruby version
(def setup-script (slurp "setup.js"))
(def ss-script (slurp "resources/public/javascripts/server-side.js"))
(def render-script (str "my.amazing_component.ns.render_me_to_s(" my-state-json-string ");"))</p>

<p>(.eval nashorn setup-script)
(.eval nashorn ss-script)
(.eval nashorn render-script) ; our html markup
```</p>

<p>I must admit that this code works on small reagent example.
I'm unable to load production code from my current project in to Nashorn.</p>

<p>Also it helps a lot if you started developing your project with server side rendering in mind.</p>

<p>Of course it's better to have some kind of "renderers pool" in JVM.
Good thing that clojure allows you to implement thing like that in few lines of code.
In ruby it's not a problem since we have 1 context per worker.</p>

<p><strong>Useful Links:</strong></p>

<ul>
<li><a href="https://groups.google.com/forum/#!topic/clojurescript/IIjUxnl4Zbw">ClojureScript mailing list topic</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ln -sf /usr/bin/emacs /usr/bin/vim ?]]></title>
    <link href="http://blog.gonzih.me/blog/2015/02/15/ln-sf-usr-bin-emacs-usr-bin-vim/"/>
    <updated>2015-02-15T19:21:00+00:00</updated>
    <id>http://blog.gonzih.me/blog/2015/02/15/ln-sf-usr-bin-emacs-usr-bin-vim</id>
    <content type="html"><![CDATA[<p>Some time ago I actually did run <code>ln -sf /usr/bin/emacs /usr/bin/vim</code>.
And left it like that for a couple of days.
I must say that it was surprisingly nice experience.
Tinkering around with elisp, building editing environment from scratch.</p>

<p>Of course interesting question is "How did I end up with this idea in my head?".</p>

<!--more-->


<p>I tried to play with emacs few times couple of years ago.
But as a modal editing kind of guy I was unable to comprehend finger bending experience that default key bindings in emacs give you.</p>

<p>I tried evil mode, but it went not so well.
Problem is that I'm also using programmer dvorak layout, so I need to remap couple of keys for better comfort.
I failed all my previous attempts because it was not very trivial at that time to remap those keys everywhere.
Also probably my lack of patience played against me.
So I gave up and continued using vim (something like 5 years of hapiness).</p>

<p>Recently ClojureScript tool called <a href="https://github.com/bhauman/lein-figwheel">figwheel</a> added repl support.
So as a result you have repl that compiles your clojure code into javascript and executes result in your browser session printing result back to you.
Development flow like that is very common practice in clojure world and one reason why it makes clojure much better.
Problem here is that it does not support nrepl (network repl) protocol and best tool for clojure in vim <a href="https://github.com/tpope/vim-fireplace">vim-fireplace</a> relies on nrepl.
I was using for some time <a href="https://github.com/sjl/tslime2.vim">tslime2</a> in vim to work with ClojureScript.
Idea is very simple - tslime allows you to send pieces of text from your vim into some tmux panel.
It works. You don't have out of the box tooling that will select your top most clojure form sadly.
Once upon a time I had discussion on #clojurescript irc and <a href="https://twitter.com/martinklepsch">@martinklepsh</a> mentioned that nowadays evil-mode is much better.
I was bored and followed that track. I did run <code>rm -rf .emacs.d</code> and started from scratch.
As a result my workflow from vim was ported to emacs in a couple of hours.
It surprised me both how simple was that and how relatively close my setup is to default one in vim/evil.
I set my default editor to emacs and continued doing my thing for a couple of days.</p>

<p>And here what I think so far.</p>

<p>Good:</p>

<ul>
<li>Evil mode is good and it's very close. It's probably closest thing to vim that I ever tried.
It's not fancy smart like vim mode in IntelliJ IDEA that actually reads your .vimrc and uses it to configure keybindings
(Big shout outs to the author of idea plugin. It's very impressive.)</li>
<li>Writing configuration in a language that I understand was a big relief.</li>
<li>Mapping configuration is simpler. You are mapping elisp function to the key. It's simpler and easier to understand than remapping mechanism in vim.</li>
<li>Helm surprised me in it's speed and functionality, I spent lot of time fighting with Ctrl-P/Unite in vim. Configuring Unite was painful experience. Helm on the other hand just works. And works well.</li>
<li>Inferior lisp is so goooood. Having editor with lisp support in mind is incredible experience for any lisp developer. <a href="https://github%20in%20inferior%20lisp%20mode%20tuned%20to%20play%20well%20with%20clojure">inf-clojure</a> is enhanced clojure mode for the inf-lisp.</li>
<li>It can do async stuff! If you used vim then you know what I mean. In emacs it's just there. Without required pythor/ruby support enabled during compilation.</li>
<li>Built-in package manager. Just run <code>package-install</code> and it's there. No NeoBundle/Bundle installation needed. No need to mess with git submodules.</li>
<li>Ability to inspect everything at run time helps during configuration. Some key executes something weird? Just run <code>describe-key</code> and see what is going on. You can do something similar in vim, but in emacs it's much better.</li>
<li>Startup time is slow and it's solvable. Just run systemd user service with <code>emacs --daemon</code> and that is enough for most cases.</li>
<li>And you still have emacs operating system at your disposal!</li>
<li>Configuring emacs from scratch made me realize that my vim configuration is really really messy and big. I need probably to think about some changes in there.</li>
</ul>


<p>Not so good:</p>

<ul>
<li>Paredit feels different from one that exists in vim. Less strict I guess most of the time and too strict when it's unnecessary. Of course this is related only to my habits and muscle memory.</li>
<li>Evil is slower.
Most of the time it's not a problem. But sometimes I'm mashing my keyboard too fast and mess happens.
Good example is replace (<code>r</code>) key.
Press <code>r:</code> too fast and you might end up in vim command line.</li>
<li>Evil is just a plugin. Sometimes you are forced to use default emacs mode in some menus/buffers that don't play well with evil.</li>
<li>Good example of painful evil integration is cider.
It just does not work with evil mode.
Most configuration examples that I was able to find on github related to cider and evil mode where just forcing default emacs mode in cider repl and related buffers.
That was big disappointment for me. I had high hopes for the cider. I'm realizing that I don't really need everything that cider provides.
I'm very happy with just ability to evaluate code, without even debugger and nice stacktraces.
But cider looked so shiny and cool. And bloated. Seems like author of cider does not use evil mode so my hopes that cider+evil story will improve are low.
After few hours of grinding my teeth over emacs configuration I gave up and decided to rely on <a href="https://github.com/clojure-emacs/inf-clojure">inf-clojure</a>.</li>
</ul>


<p>Will I continue using emacs? Yes.</p>

<p>Will it be my default editor? Probably no.
Vim feels more reliable because it provides modal editing experience out of the box.
In emacs it an option.
I'm totally fine with giving away all that goodness that emacs provides to have proper editing experience <strong>all the time</strong>.
In every buffer, in every menu.
And I will continue slowly improving my emacs configuration.</p>

<p>This experiment reminded me how many things are missing from my setup.
It also reminded me that <a href="https://neovim.org">neovim</a> might be next big thing in my tool belt.
I'm really hoping to see big movement around neovim once project becomes more or less compatible with current viml based configurations.</p>

<p><strong>PS</strong></p>

<ul>
<li><a href="http://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/">Here</a> is very good tutorial to get vim users started in emacs.</li>
<li>My .emacs.d is <a href="https://github.com/Gonzih/.emacs.d">here</a>. I tried to keep it minimalistic.</li>
<li>My .vim is <a href="https://github.com/Gonzih/.vim">here</a>.</li>
<li>If you are looking for the best vim like experience in emacs please take a look at the <a href="https://github.com/syl20bnr/spacemacs">spacemacs project</a>.</li>
<li>Looking for the good color theme in emacs? Take a look at the port of <a href="https://github.com/morhetz/gruvbox">vim's gruvbox theme</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Two way data bindings in Reagent]]></title>
    <link href="http://blog.gonzih.me/blog/2014/10/22/two-way-data-bindings-in-reagent/"/>
    <updated>2014-10-22T17:29:00+00:00</updated>
    <id>http://blog.gonzih.me/blog/2014/10/22/two-way-data-bindings-in-reagent</id>
    <content type="html"><![CDATA[<p>Small code snippet showing ability to generate 2 way data bindings in Reagent.
Underneath it's all about core.async.
Also provides ability to apply transformation using transducers.</p>

<p>```clojure</p>

<p>(defonce form (atom {}))</p>

<p>(defn bind-input
  "Generat on-change callback,
   bind value to form-key of form-atom.
   Provides ability to implement transformation using transducers."
  [form-atom form-key xform]
  (let [local-chan (chan 1 xform)]</p>

<pre><code>(go-loop []
  (swap! form-atom assoc form-key (&lt;! local-chan))
  (recur))
(fn [event]
  (put! local-chan
        (.-value (.-target event))))))
</code></pre>

<p>(defn bound-input
  "Generate input,
   create two way data binding
   between input value and value under form-key in form-atom.
   Provides ability to implement transformation using transducers."
  [attrs form-atom form-key xform]
  [:input (merge attrs</p>

<pre><code>             {:value (form-key @form-atom)
              :on-change (bind-input form-atom form-key xform)})])
</code></pre>

<p>(defn main-component []
  [:div
   [:h3 (:name @form) " value"]
   [bound-input {:type :text} form :name (filter #(> 15 (count %)))]])</p>

<p>(reagent/render-component [main-component]</p>

<pre><code>                      (js/document.getElementById "content"))
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Replacing shell scripts with Clojure+JamVM]]></title>
    <link href="http://blog.gonzih.me/blog/2014/09/28/replacing-shell-scripts-with-clojure/"/>
    <updated>2014-09-28T11:04:00+00:00</updated>
    <id>http://blog.gonzih.me/blog/2014/09/28/replacing-shell-scripts-with-clojure</id>
    <content type="html"><![CDATA[<p>We all hate shell scripting.
Scripts are annoyingly hard to debug, test and verify.
Would be lovely, to use some kind of lisp for scripting, right?
To do interactive development with repl in your favorite editor.
To write it in a nice predictable language that you also enjoy.
But sometimes it's impossible to add some external dependencies to the system.
What if you have only JVM to your disposal, will you be able to pull it off only with JVM and clojure.jar?</p>

<!--more-->


<h1>Basic setup</h1>

<p>First what we will need is to get clojure jar file:</p>

<p><code>
wget -O /opt/clojure.jar 'http://central.maven.org/maven2/org/clojure/clojure/1.6.0/clojure-1.6.0.jar'
</code></p>

<p>Next lets create executable that will live in <code>/usr/bin</code> (or <code>/opt/bin</code> or <code>/home/youruser/bin</code>):</p>

<p>```bash /usr/bin/clojure</p>

<h1>!/bin/sh</h1>

<p>exec java -jar /opt/clojure.jar "$@"
```</p>

<p>And now it's time for our hello world script:</p>

<p>```clojure /opt/test.clj</p>

<h1>!/usr/bin/clojure</h1>

<p>(println "hello world")
```</p>

<p>Make it executable:</p>

<p><code>bash
chmod +x /opt/test.clj
</code></p>

<p>And run it:</p>

<p><code>bash
$ /opt/test.clj
hello world
</code></p>

<p>Yay! But it feels kind of slow:</p>

<p>```bash
time /opt/test.clj
hello world</p>

<p>real  0m2.684s
user  0m2.239s
sys   0m0.186s
```</p>

<p>2 seconds startup time, not really suitable for scripting, right?
Can we improve that? What if there would be JVM with fast startup and low memory usage.</p>

<h1>Introducing JamVM.</h1>

<p><em>"But... but you told us that there is only JVM available on production system without ability to add external dependencies."</em></p>

<p>I lied, sorry.</p>

<p>Compiling JamVM with OpenJDK support:</p>

<p>```bash</p>

<h1>Fetching required dependencies and source</h1>

<p>apt-get -y install openjdk-7-jdk openjdk-7-jre build-essential zlib1g-dev
cd /opt
wget -O jamvm-2.0.0.tar.gz 'http://downloads.sourceforge.net/project/jamvm/jamvm/JamVM%202.0.0/jamvm-2.0.0.tar.gz'
tar -xvzf jamvm-2.0.0.tar.gz</p>

<h1>Building</h1>

<p>cd /opt/jamvm-2.0.0
./configure --with-java-runtime-library=openjdk7 &amp;&amp; make check &amp;&amp; make &amp;&amp; make install</p>

<h1>Installing in to the openjdk installation</h1>

<p>mkdir /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/amd64/jamvm
cp /usr/local/jamvm/lib/libjvm.so /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/amd64/jamvm/libjvm.so</p>

<h1>Trying it out</h1>

<p>java -jamvm -version
```</p>

<p>JamVM will be installed as separate vm in openjdk, so it will not mess with existing installation.
You will need to use -jamvm option to java command to run it with small overhead vm.</p>

<p>Let's update our clojure executable:</p>

<p>```bash /usr/bin/clojure</p>

<h1>!/bin/sh</h1>

<p>exec java -jamvm -jar /opt/clojure.jar "$@"
```</p>

<p>Let's try it out:</p>

<p>```bash
time /opt/test.clj
hello world</p>

<p>real  0m0.866s
user  0m0.764s
sys   0m0.076s
```</p>

<p>Better, right?</p>

<h2>How slow is JamVM? Some benchmarks:</h2>

<p>```text
Clojure 1.6</p>

<p>JamVM:</p>

<p>(factorial 5000) Avg: 248.65890986500017
(fib 20)         Avg: 35.33471996000001
(sort-seq)       Avg: 405.7438969800002</p>

<p>OpenJDK:</p>

<p>(factorial 5000) Avg: 25.016900630000006
(fib 20)         Avg: 0.69957772
(sort-seq)       Avg: 11.553695560000001
```</p>

<p>Much slower, but if you think about it
shell scripting most of the time is about executing external commands,
IO and data filtering. Might be as well not so bad.
Also memory usage of JamVM makes it perfect for embedded systems.</p>

<h2>Why not use something like lein exec?</h2>

<p>Lein exec is nice. But it adds overhead.
If you need external dependencies you can solve it (in theory)
with classpath manipulations in java command (<code>java -cp dep.jar:dep2.jar:.</code>).
Still you can plug lein exec to JamVM if you want.</p>

<h3>Update</h3>

<p>I just noticed that in Ubuntu 14:04 repos there is already JamVM package,
so you can just run <code>apt-get -y install icedtea-7-jre-jamvm</code> to install latest build.</p>
]]></content>
  </entry>
  
</feed>
