<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: clojure | Max Gonzih]]></title>
  <link href="http://blog.gonzih.me/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://blog.gonzih.me/"/>
  <updated>2014-09-28T17:41:22+02:00</updated>
  <id>http://blog.gonzih.me/</id>
  <author>
    <name><![CDATA[Max Gonzih ]]></name>
    <email><![CDATA[gonzih@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Replacing shell scripts with Clojure+JamVM]]></title>
    <link href="http://blog.gonzih.me/blog/2014/09/28/replacing-shell-scripts-with-clojure/"/>
    <updated>2014-09-28T11:04:00+02:00</updated>
    <id>http://blog.gonzih.me/blog/2014/09/28/replacing-shell-scripts-with-clojure</id>
    <content type="html"><![CDATA[<p>We all hate shell scripting.
Scripts are annoyingly hard to debug, test and verify.
Would be lovely, to use some kind of lisp for scripting, right?
To do interactive development with repl in your favorite editor.
To write it in a nice predictable language that you also enjoy.
But sometimes it's impossible to add some external dependencies to the system.
What if you have only JVM to your disposal, will you be able to pull it off only with JVM and clojure.jar?</p>

<!--more-->


<h1>Basic setup</h1>

<p>First what we will need is to get clojure jar file:</p>

<p><code>
wget -O /opt/clojure.jar 'http://central.maven.org/maven2/org/clojure/clojure/1.6.0/clojure-1.6.0.jar'
</code></p>

<p>Next lets create executable that will live in <code>/usr/bin</code> (or <code>/opt/bin</code> or <code>/home/youruser/bin</code>):</p>

<p>```bash /usr/bin/clojure</p>

<h1>!/bin/bash</h1>

<p>java -jar /opt/clojure.jar $@
```</p>

<p>And now it's time for our hello world script:</p>

<p>```clojure /opt/test.clj</p>

<h1>!/usr/bin/clojure</h1>

<p>(println "hello world")
```</p>

<p>Make it executable:</p>

<p><code>bash
chmod +x /opt/test.clj
</code></p>

<p>And run it:</p>

<p><code>bash
$ /opt/test.clj
hello world
</code></p>

<p>Yay! But it feels kind of slow:</p>

<p>```bash
time /opt/test.clj
hello world</p>

<p>real  0m2.684s
user  0m2.239s
sys   0m0.186s
```</p>

<p>2 seconds startup time, not really suitable for scripting, right?
Can we improve that? What if there would be JVM with fast startup and low memory usage.</p>

<h1>Introducing JamVM.</h1>

<p><em>"But but you told us that there is only JVM available on production system without ability to add external dependencies."</em></p>

<p>I lied, sorry.</p>

<p>Compiling JamVM with OpenJDK support:</p>

<p>```bash</p>

<h1>Fetching required dependencies and source</h1>

<p>apt-get -y install openjdk-7-jdk openjdk-7-jre build-essential zlib1g-dev
cd /opt
wget -O jamvm-2.0.0.tar.gz 'http://downloads.sourceforge.net/project/jamvm/jamvm/JamVM%202.0.0/jamvm-2.0.0.tar.gz'
tar -xvzf jamvm-2.0.0.tar.gz</p>

<h1>Building</h1>

<p>cd /opt/jamvm-2.0.0
./configure --with-java-runtime-library=openjdk7 &amp;&amp; make check &amp;&amp; make &amp;&amp; make install</p>

<h1>Installing in to the openjdk installation</h1>

<p>mkdir /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/amd64/jamvm
cp /usr/local/jamvm/lib/libjvm.so /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/amd64/jamvm/libjvm.so</p>

<h1>Trying it out</h1>

<p>java -jamvm -version
```</p>

<p>JamVM will be installed as separate vm in openjdk, so it will not mess with existing installation.
You will need to use -jamvm option to java command to run it with small overhead vm.</p>

<p>Let's update our clojure executable:</p>

<p>```bash /usr/bin/clojure</p>

<h1>!/bin/bash</h1>

<p>java -jamvm -jar /opt/clojure.jar $@
```</p>

<p>Let's try it out:</p>

<p>```bash
time /opt/test.clj
hello world</p>

<p>real  0m0.866s
user  0m0.764s
sys   0m0.076s
```</p>

<p>Better, right?</p>

<h2>How slow is JamVM? Some benchmarks:</h2>

<p>```text
Clojure 1.6</p>

<p>JamVM:</p>

<p>(factorial 5000) Avg: 248.65890986500017
(fib 20)         Avg: 35.33471996000001
(sort-seq)       Avg: 405.7438969800002</p>

<p>OpenJDK:</p>

<p>(factorial 5000) Avg: 25.016900630000006
(fib 20)         Avg: 0.69957772
(sort-seq)       Avg: 11.553695560000001
```</p>

<p>Much slower, but if you think about it
shell scripting most of the time is about executing external commands,
IO and data filtering. Might be as well not so bad.
Also memory usage of JamVM makes it perfect for embedded systems.</p>

<h2>Why not use something like lein exec?</h2>

<p>Lein exec is nice. But it adds overhead.
If you need external dependencies you can solve it (in theory)
with classpath manipulations in java command (<code>java -cp dep.jar:dep2.jar:.</code>).
Still you can plug lein exec to JamVM if you want.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HN Tray icon in 50 lines of Clojure]]></title>
    <link href="http://blog.gonzih.me/blog/2014/05/24/hn-tray-icon-in-50-lines-of-clojure/"/>
    <updated>2014-05-24T22:03:00+02:00</updated>
    <id>http://blog.gonzih.me/blog/2014/05/24/hn-tray-icon-in-50-lines-of-clojure</id>
    <content type="html"><![CDATA[<p>Today I got a little bit bored and spend few hours poking around with java.awt in Clojure.
Result is tray app that shows stories from HN front page.
Just in ~50 lines of Clojure code.
Enjoy!</p>

<p><a href="https://github.com/Gonzih/hn-tray.clj">Github Project.</a></p>

<p>Source code is below:</p>

<!--more-->


<p>```clojure
(ns hn.core
  (:require [cheshire.core :as json]</p>

<pre><code>        [clojure.java.browse :refer [browse-url]]
        [clojure.java.io :refer [resource]])
</code></pre>

<p>  (:import [java.awt SystemTray TrayIcon PopupMenu MenuItem Toolkit]</p>

<pre><code>       [java.awt.event ActionListener])
</code></pre>

<p>  (:gen-class))</p>

<p>(defn menu-item [label callback]
  (let [menu (MenuItem. label)</p>

<pre><code>    listener (proxy [ActionListener] []
               (actionPerformed [event] (callback)))]
(.addActionListener menu listener)
menu))
</code></pre>

<p>(def hn-api-url "http://api.ihackernews.com/page")</p>

<p>(defn hn-items []
  (-> hn-api-url</p>

<pre><code>  slurp
  (json/parse-string true)
  :items
  (#(sort-by :points %))
  reverse))
</code></pre>

<p>(defn add-hn-to-menu! [menu]
  (letfn [(mapfn [{:keys [title url commentCount points]}]</p>

<pre><code>        (let [full-title (format "%-4s (%-4s) - %s" points commentCount title)
              menu-item (menu-item full-title #(browse-url url))]
          (println full-title)
          (.add menu menu-item)))]
</code></pre>

<p>  (doall (map mapfn (hn-items)))))</p>

<p>(defn exit []
  (shutdown-agents)
  (System/exit 0))</p>

<p>(defn -main [&amp; args]
  (let [tray (SystemTray/getSystemTray)</p>

<pre><code>    image (.getImage (Toolkit/getDefaultToolkit)
                     (resource "icon.png"))
    icon (TrayIcon. image)
    exit (menu-item "Exit" exit)]
(.setImageAutoSize icon true)
(.add tray icon)
(loop []
  (let [popup (PopupMenu.)]
    (println "Updating items")
    (add-hn-to-menu! popup)
    (.add popup exit)
    (.setPopupMenu icon popup)
    (Thread/sleep (* 5 60 1000))
    (recur)))))
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My first experience with core.typed]]></title>
    <link href="http://blog.gonzih.me/blog/2013/08/30/my-first-experience-with-core-dot-typed/"/>
    <updated>2013-08-30T12:30:00+02:00</updated>
    <id>http://blog.gonzih.me/blog/2013/08/30/my-first-experience-with-core-dot-typed</id>
    <content type="html"><![CDATA[<p>Today I started improving my feeds2imap.clj project with core.typed.
And already hit few issues, so this post is something like collection of tips how to solve issues with core.typed based on my experience.
I couldn't find answers on my issues in wiki or documentation.
But I got answers annoying Ambrose Bonnaire-Sergeant on Google+.
Thank you for your patience, man!
And keep doing what you are doing, core.typed is just amazing thing!</p>

<!--more-->


<h3>Unresolved constructor invocation</h3>

<p>Core.typed can't match constructor based on arguments type,
you should provide type hints to help core.typed with that.</p>

<h3>By default core.typed assumes that all java methods can return nil</h3>

<p>Use <code>(non-nil-return ClassOrObject/methodName :all)</code> to tell core.typed that method won't return nil.
Core.typed will trust you and will skip further checks.</p>

<p>Or for example if you are expecting String as a result you can convert result to String with str before returning it.</p>

<h3>non-nil-return in core.typed works only on methods</h3>

<p>And if you have static method then something like that would not work:</p>

<p>```clojure
(non-nil-return javax.mail.Message$RecipientType/TO :all)</p>

<p>(ann recipient-type-to [-> Message$RecipientType])
(defn ^Message$RecipientType recipient-type-to []
  (Message$RecipientType/TO))</p>

<p>(comment
  Type mismatch:
  Expected:       (Fn [-> Message$RecipientType])
  Actual:         (Fn [-> (U Message$RecipientType nil)]))
```</p>

<p>Solution:</p>

<p>```clojure
(non-nil-return javax.mail.Message$RecipientType/TO :all)</p>

<p>(ann recipient-type-to [-> Message$RecipientType])
(defn ^Message$RecipientType recipient-type-to
  []
  {:post [%]}
  (Message$RecipientType/TO))
```</p>

<p>Which is the same as:</p>

<p>```clojure
(non-nil-return javax.mail.Message$RecipientType/TO :all)</p>

<p>(ann recipient-type-to [-> Message$RecipientType])
(defn ^Message$RecipientType recipient-type-to []
  (let [temp (Message$RecipientType/TO)]</p>

<pre><code>(assert temp)
temp)
</code></pre>

<p>```</p>

<p>So unless assert evaluates temp to logical true exception will be raised
and function will always return non nil value, which makes core.typed happy.</p>

<h3>Defining Parameterized alias type</h3>

<p>```clojure
(def-alias Folder
  (TFn [[x :variance :covariant]] (Map Keyword x)))</p>

<p>(comment
  (Folder Items)
  (Folder Urls))
```</p>

<p><a href="https://github.com/Gonzih/feeds2imap.clj/commit/1c41d814bdb054d57e644013c85275ec9a45a114">Here is</a> commit with changes related to core.typed.
I must say writing type annotations for code that you wrote few months ago is tricky.
But still I enjoyed process and results and I'm still a little bit amazed about all core.typed thing.
Power of lisp combined with really smart people :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Speed/Ping test graphs with Clojure and Raspberry Pi]]></title>
    <link href="http://blog.gonzih.me/blog/2013/08/24/speed-slash-ping-test-graphs-with-clojure-and-raspberry-pi/"/>
    <updated>2013-08-24T14:02:00+02:00</updated>
    <id>http://blog.gonzih.me/blog/2013/08/24/speed-slash-ping-test-graphs-with-clojure-and-raspberry-pi</id>
    <content type="html"><![CDATA[<p>I'm often complaining about my ISP quality.
Sometimes pings are high, sometimes download speed goes down.
So I decided to make sure it's my ISP fault and not just my opinion based on my hate to them.</p>

<p>How to do so? Let's collect data about download speed and pings over time, and show some graphs based on that data.</p>

<!-- more -->


<p>I have unused Raspberry Pi right now, so it will be used to collect data.</p>

<h2>Speedtest data</h2>

<p>For speedtest I will be using python script that uses speedtest.net servers.
Pi is running Pidora right now, so let's install script dependencies.</p>

<p><code>sh
yum -y install python-argparse python-lxml
</code></p>

<p>Script is hosted on <a href="https://github.com/Janhouse/tespeed">github</a>.
Let's get the script.</p>

<p><code>sh
mkdir ~/scripts
wget https://raw.github.com/Janhouse/tespeed/master/tespeed.py -O ~/scripts/speedtest.py
</code></p>

<p>You can test script running it with:</p>

<p><code>sh
python ~/scripts/speedtest.py
</code></p>

<p>Now let's wrap python script into additional shell script to store time of data collection in csv.
I'm not sure if I need time for now, but let's keep it anyway.
We will silence stderr from the script and output results as csv.</p>

<p>```sh ~/bin/speedtest.zsh</p>

<h1>!/usr/bin/zsh</h1>

<p>echo "\"$(date -R)\",$(python ~/scripts/tespeed.py --csv -s)"
```</p>

<p>Let's put script into crontab to run every 5 minutes, also let's redirect stderr to /dev/null in case of Ethernet unavailability or some other issues.</p>

<p><code>sh crontab
*/5 * * * * ~/bin/speedtest.zsh 2&gt;/dev/null &gt;&gt; ~/.speedtest.csv
</code></p>

<h2>Ping data</h2>

<p>For ping data we will be running <code>ping</code> command with 100 packets (<code>ping -c 100</code>) with google dns as target (8.8.8.8) and storing avg value with time to csv file.</p>

<p>```sh ~/bin/pingtest.zsh</p>

<h1>!/usr/bin/zsh</h1>

<p>AVG=$(ping -c 100 8.8.8.8 | grep rtt | sed -r 's#.*\=\s.+/(.+)/.+/.+#\1#')</p>

<p>echo "\"$(date -R)\",$AVG"
```</p>

<p><code>sh crontab
*/5 * * * * ~/bin/pingtest.zsh 2&gt;/dev/null &gt;&gt; ~/.pingtest.csv
</code></p>

<h2>Graphs</h2>

<p>For data visualization let's use Clojure with Incanter. Here is clojure code:</p>

<p>```clojure
(ns incanter-graphs.core
  (:require [incanter.core :refer :all]</p>

<pre><code>        [incanter.stats :refer :all]
        [incanter.charts :refer :all]
        [clojure-csv.core :refer :all])
</code></pre>

<p>  (:gen-class))</p>

<p>(defn to-f [is] (Float/parseFloat is))</p>

<p>(defn get-f-col [data col]
  (map to-f (sel data :cols col)))</p>

<p>(defn init-chart [data rng {:keys [x-label y-label]}]
  (line-chart rng data :x-label x-label</p>

<pre><code>                   :y-label y-label))
</code></pre>

<p>(defn add-to-chart [chart data rng]
  (reduce #(add-categories %1 rng %2) chart data))</p>

<p>(defn draw-file [filename cols &amp; {:as opts}]
  (let [data (slurp filename)</p>

<pre><code>    csv (parse-csv data :delimiter \,)
    rng (range 0 (count csv))
    data (map (partial get-f-col csv) cols)
    chart (init-chart (first data) rng opts)
    chart-to-show (add-to-chart chart (rest data) rng)]
(view chart-to-show)))
</code></pre>

<p>(defn -main [speedfile pingfile &amp; args]
  (draw-file speedfile [1 2] :x-label "Time" :y-label "Speed")
  (draw-file pingfile [1] :x-label "Time" :y-label "Ping time"))
```</p>

<p>Let's put all launch process to Makefile:</p>

<p>```makefile Makefile
default:</p>

<pre><code>scp raspberry-pi.local:.speedtest.csv /tmp/
scp raspberry-pi.local:.pingtest.csv /tmp/
#Remove lines with only time (script failure)
grep "[^,]$$" /tmp/.speedtest.csv &gt; /tmp/.speedtest-fixed.csv
grep "[^,]$$" /tmp/.pingtest.csv &gt; /tmp/.pingtest-fixed.csv
lein run /tmp/.speedtest-fixed.csv /tmp/.pingtest-fixed.csv
</code></pre>

<p>```</p>

<p>I adjusted my router, so QoS daemon will give maximum priority to traffic from my Raspberry Pi, so data will be cleaner.
And now we can see some visualization.</p>

<p><img src="https://dl.dropboxusercontent.com/u/4109351/octopress/ping-speed-graphs/speed.png" alt="Speed Graph" />
<img src="https://dl.dropboxusercontent.com/u/4109351/octopress/ping-speed-graphs/ping.png" alt="Ping Graph" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RSS/Atom reader in Clojure via IMAP]]></title>
    <link href="http://blog.gonzih.me/blog/2013/06/28/rss-slash-atom-reader-in-clojure-via-imap/"/>
    <updated>2013-06-28T10:15:00+02:00</updated>
    <id>http://blog.gonzih.me/blog/2013/06/28/rss-slash-atom-reader-in-clojure-via-imap</id>
    <content type="html"><![CDATA[<h3>Motivation</h3>

<p>Google Reader was shut down and I started looking for alternatives.
And sadly I did not found anything close to Google Reader experience.
There are plenty good alternatives, but all of them suffer from some kind of background noise (social based features, weird hotkeys, weird ui, unusable mobile clients and etc.).
All I wanted was simple to use news reader.</p>

<!-- more -->


<h3>Idea</h3>

<p>Then I found post in the Racket community about storing your feeds in the IMAP folders using "APPEND" command by <a href="http://www.greghendershott.com/2013/05/feeds2gmail.html">Greg Hendershott</a>.
That was it. Simplest possible solution, that I can run on small device or server by cron. I played a little bit with Racket source code and decided to write my own version to do the job.</p>

<h3>Clojure version</h3>

<p>First I implemented my <a href="https://github.com/Gonzih/feeds2imap.rb">prototype in Ruby</a> in few hours. I picked up Ruby because of built-in rss/atom and imap libraries.
I used it for few days and liked it. Simple, reliable solution.
So then I decided to rewrite it in Clojure.
Why Clojure?
Because it's pure fun to use.
I decided to use java.mail framework for message storing and folder manipulations, feedparser-clj to fetch and parse rss/atom feeds and hiccup for templating.
I was really pleased with feedparser-clj in comparison with Ruby built-in library.
java.mail framework was not so bad as I was expecting at first.</p>

<h3>How it works?</h3>

<p>Here is project logic:</p>

<ul>
<li>Fetch folders and urls from feeds file.</li>
<li>Fetch and parse RSS/Atom data from urls.</li>
<li>Select only new items using cache file.</li>
<li>Create required imap folders.</li>
<li>Store new items as email messages.</li>
<li>Mark items as read (put md5 hashes in to the clj file with set of old hashes).</li>
</ul>


<p>It's running now by cron (every hour) on my BeagleBone (using latest ejre version).</p>

<p>Source code is hosted on github <a href="https://github.com/Gonzih/feeds2imap.clj">here</a>. Take a look at project README for usage.</p>

<h3>More implementations</h3>

<ul>
<li><a href="https://github.com/Gonzih/feeds2imap.rb">My Ruby prototype</a></li>
<li><a href="https://github.com/Gonzih/feeds2imap.clj">My Clojure implementation</a></li>
<li><a href="https://github.com/greghendershott/feeds2gmail">Racket implementation</a></li>
<li><a href="https://github.com/cordawyn/rss2imap">Haskell implementation</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
