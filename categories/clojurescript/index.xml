<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Max Gonzih</title>
    <link>http://blog.gonzih.me/categories/clojurescript/index.xml</link>
    <description>Recent content on Max Gonzih</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>gonzih@gmail.com (Max Gonzih)</managingEditor>
    <webMaster>gonzih@gmail.com (Max Gonzih)</webMaster>
    <copyright>This work is licensed under a Creative Commons Attribution 4.0 International License.</copyright>
    <atom:link href="/categories/clojurescript/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Nvim terminal &#43; ClojureScript and figwheel</title>
      <link>http://blog.gonzih.me/blog/2015/06/15/nvim-terminal-&#43;-clojurescript-and-figwheel/</link>
      <pubDate>Mon, 15 Jun 2015 00:00:00 +0000</pubDate>
      <author>gonzih@gmail.com (Max Gonzih)</author>
      <guid>http://blog.gonzih.me/blog/2015/06/15/nvim-terminal-&#43;-clojurescript-and-figwheel/</guid>
      <description>&lt;p&gt;This is a small post on how to improve your ClojureScript development flow in NeoVim using its terminal feature.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://neovim.io/&#34;&gt;NeoVim&lt;/a&gt; nowadays is almost fully compatible with vim.
It is able to reuse my &lt;a href=&#34;https://github.com/Gonzih/.vim/blob/master/vimrc&#34;&gt;.vimrc&lt;/a&gt; file without any issues.
And recently it got proper terminal emulator built-in.
So how about reusing it for ClojureScript development?&lt;/p&gt;

&lt;p&gt;If you are lazy (like I am) and don&amp;rsquo;t want to setup piggieback support
for fireplace.vim or don&amp;rsquo;t feel like tmux integration is good enough
this solution should be your new starting point.&lt;/p&gt;

&lt;p&gt;Just open some clojure[script] file and create second split.
Open terminal using &lt;code&gt;:terminal&lt;/code&gt; command.&lt;/p&gt;

&lt;p&gt;Here are some keybindings that will help you to send code from
your clojure buffer to the terminal buffer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;if has(&amp;quot;nvim&amp;quot;)
  &amp;quot; Open terminal and run lein figwheel
  nmap &amp;lt;Leader&amp;gt;term &amp;lt;C-w&amp;gt;v:terminal&amp;lt;CR&amp;gt;lein figwheel&amp;lt;CR&amp;gt;&amp;lt;C-\&amp;gt;&amp;lt;C-n&amp;gt;&amp;lt;C-w&amp;gt;p
  &amp;quot; Evaluate anything from the visual mode in the next window
  vmap &amp;lt;buffer&amp;gt; ,e y&amp;lt;C-w&amp;gt;wpi&amp;lt;CR&amp;gt;&amp;lt;C-\&amp;gt;&amp;lt;C-n&amp;gt;&amp;lt;C-w&amp;gt;p
  &amp;quot; Evaluate outer most form
  nmap &amp;lt;buffer&amp;gt; ,e ^v%,e
  &amp;quot; Evaluate buffer&amp;quot;
  nmap &amp;lt;buffer&amp;gt; ,b ggVG,e
endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hey! Now you can finally stop looking at the emacs land!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ServerSide rendering of Reagent components</title>
      <link>http://blog.gonzih.me/blog/2015/02/16/serverside-rendering-of-reagent-components/</link>
      <pubDate>Mon, 16 Feb 2015 00:00:00 +0000</pubDate>
      <author>gonzih@gmail.com (Max Gonzih)</author>
      <guid>http://blog.gonzih.me/blog/2015/02/16/serverside-rendering-of-reagent-components/</guid>
      <description>&lt;p&gt;Great thing about React is that you can write what people nowadays call &amp;ldquo;isomorphic JavaScript&amp;rdquo;.
In this post we will not discuss how wrong this term is in many ways,
but instead we will focus on how to achieve similar results in your ClojureScript code using Reagent library.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;In my experience simplest optimization to run in some js engine on server side is whitespace.
It does not do any renaming/restructuring of your code but eliminates need to take care of dependencies loading.
So our compiler configuration should look something like that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;{:id &amp;quot;server-side&amp;quot;
 :source-paths [&amp;quot;src&amp;quot;]
 :compiler {:output-to &amp;quot;resources/public/javascripts/server-side.js&amp;quot;
            :output-dir &amp;quot;resources/public/javascripts/out-server-side&amp;quot;
            :preamble [&amp;quot;meta-inf/resources/webjars/react/0.12.1/react-with-addons.min.js&amp;quot;]
            :pretty-print false
            :warnings true
            :optimizations :whitespace}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next step is to make sure that all functions that use browser specific stuff like document/window are moved in to react lifecycle methods:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def main-component
  (with-meta
    (fn [] ...)
    {:component-did-mount (comp init-my-scroll-handler!
                                also-init-my-go-loop!)}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next let&amp;rsquo;s create function that will do some rendering to the string.
I like to keep this function in a component specific ns just for convenience.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def ^:export render-me-to-s [initial-state]
  (reset! my-main-state (js-&amp;gt;clj initial-state))
  ; Render component to markup without reactid
  (reagent.core/render-to-static-markup [main-component])
  ; Or render component to ready to-go react markup
  (reagent.core/render-to-string [main-component]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now server side bootstrapping, most of this code was taken from &lt;a href=&#34;https://github.com/reactjs/react-rails&#34;&gt;react-rails plugin&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;First of all react expects to have global or window objects in your js engine (setup.js):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var global = global || this;
var self = self || this;
var window = window || this;
var console = global.console || {};
[&#39;error&#39;, &#39;log&#39;, &#39;info&#39;, &#39;warn&#39;].forEach(function (fn) {
  if (!(fn in console)) {
    console[fn] = function () {};
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s try and use all this in our code (for now in Ruby):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;cxt = V8::Context.new
cxt.load(&#39;setup.js&#39;)
cxt.load(&#39;resources/public/javascripts/server-side.js&#39;)
html = cxt.eval(&amp;quot;my.amazing_component.ns.render_me_to_s(#{init_state.to_json})&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s it. As a way to pass data from ruby to clojurescript json works fine.
Sometimes you might want to use &lt;code&gt;ActionController::Base.helpers.j&lt;/code&gt; helper that will
escape your data for usage inside json, but most of the time you should be alright without it.&lt;/p&gt;

&lt;p&gt;If you have issues with core.async there are 2 ways to solve it.
I personally prefer to move core.async initialization into some lifecycle method.
Another solution is to implement setTimeout function like that in your &lt;code&gt;setup.js&lt;/code&gt; snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;goog.global.setTimeout = function(cb, t) {
    cb();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now frontend part. First let&amp;rsquo;s in-line generated html in to the container:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;&amp;lt;div id=&amp;quot;content&amp;quot;&amp;gt;&amp;lt;%= html %&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then let&amp;rsquo;s write function that will render our component on frontend:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def ^:export mount-me [initial-state]
  (reset! my-main-state (js-&amp;gt;clj initial-state))
  (reagent.core/render [main-component]
                       (js/document.getElementById &amp;quot;content&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As far as I understand react should reuse your markup on frontend and just attach new handlers to it.
Am I wrong on this one? Don&amp;rsquo;t know yet.&lt;/p&gt;

&lt;p&gt;Inline javascript that you should use on frontend looks like that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;&amp;lt;script&amp;gt;
my.amazing_component.ns.mount_me(&amp;lt;%= init_state.to_json %&amp;gt;)
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;nashorn-example-result-of-my-experiments-in-the-repl&#34;&gt;Nashorn example (result of my experiments in the REPL)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(import &#39;[javax.script ScriptEngineManager])
(def nashorn (.getEngineByName (ScriptEngineManager.) &amp;quot;nashorn&amp;quot;))

; Same as in ruby version
(def setup-script (slurp &amp;quot;setup.js&amp;quot;))
(def ss-script (slurp &amp;quot;resources/public/javascripts/server-side.js&amp;quot;))
(def render-script (str &amp;quot;my.amazing_component.ns.render_me_to_s(&amp;quot; my-state-json-string &amp;quot;);&amp;quot;))

(.eval nashorn setup-script)
(.eval nashorn ss-script)
(.eval nashorn render-script) ; our html markup
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I must admit that this code works on small reagent example.
I&amp;rsquo;m unable to load production code from my current project in to Nashorn.&lt;/p&gt;

&lt;p&gt;Also it helps a lot if you started developing your project with server side rendering in mind.&lt;/p&gt;

&lt;p&gt;Of course it&amp;rsquo;s better to have some kind of &amp;ldquo;renderers pool&amp;rdquo; in JVM.
Good thing that clojure allows you to implement thing like that in few lines of code.
In ruby it&amp;rsquo;s not a problem since we have 1 context per worker.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Useful Links:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://groups.google.com/forum/#!topic/clojurescript/IIjUxnl4Zbw&#34;&gt;ClojureScript mailing list topic&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Two way data bindings in Reagent</title>
      <link>http://blog.gonzih.me/blog/2014/10/22/two-way-data-bindings-in-reagent/</link>
      <pubDate>Wed, 22 Oct 2014 00:00:00 +0000</pubDate>
      <author>gonzih@gmail.com (Max Gonzih)</author>
      <guid>http://blog.gonzih.me/blog/2014/10/22/two-way-data-bindings-in-reagent/</guid>
      <description>&lt;p&gt;Small code snippet showing ability to generate 2 way data bindings in Reagent.
Underneath it&amp;rsquo;s all about core.async.
Also provides ability to apply transformation using transducers.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;
(defonce form (atom {}))

(defn bind-input
  &amp;quot;Generat on-change callback,
   bind value to form-key of form-atom.
   Provides ability to implement transformation using transducers.&amp;quot;
  [form-atom form-key xform]
  (let [local-chan (chan 1 xform)]
    (go-loop []
      (swap! form-atom assoc form-key (&amp;lt;! local-chan))
      (recur))
    (fn [event]
      (put! local-chan
            (.-value (.-target event))))))

(defn bound-input
  &amp;quot;Generate input,
   create two way data binding
   between input value and value under form-key in form-atom.
   Provides ability to implement transformation using transducers.&amp;quot;
  [attrs form-atom form-key xform]
  [:input (merge attrs
                 {:value (form-key @form-atom)
                  :on-change (bind-input form-atom form-key xform)})])

(defn main-component []
  [:div
   [:h3 (:name @form) &amp;quot; value&amp;quot;]
   [bound-input {:type :text} form :name (filter #(&amp;gt; 15 (count %)))]])

(reagent/render-component [main-component]
                          (js/document.getElementById &amp;quot;content&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>ClojureScript on BeagleBone: simple benchmark with Node.js</title>
      <link>http://blog.gonzih.me/blog/2013/01/23/clojurescript-on-beaglebone-simple-benchmark-with-node-dot-js/</link>
      <pubDate>Wed, 23 Jan 2013 00:00:00 +0000</pubDate>
      <author>gonzih@gmail.com (Max Gonzih)</author>
      <guid>http://blog.gonzih.me/blog/2013/01/23/clojurescript-on-beaglebone-simple-benchmark-with-node-dot-js/</guid>
      <description>&lt;p&gt;Benchmark is based on my &lt;a href=&#34;http://blog.gonzih.me/blog/2012/09/07/clojure-on-beaglebone-openjdk-vs-oracle-embedded-jre-benchmark/&#34;&gt;previous experiments&lt;/a&gt; with BeagleBone and Clojure. Setup is the same. BeagleBone is running Ubuntu 12.04. Cpu is running on 500 Mhz.
Node version is 0.6.12. ClojureScript is compiled with advanced and simple optimizations.
&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Gonzih/clojurescript-small-benchmark-for-embed&#34;&gt;Code&lt;/a&gt; is modified to run on top of the JavaScript:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(ns benchmark.core)

(defn factorial [x]
  (reduce * (range 1 (inc x))))

(defn fib [n]
  (if (&amp;lt;= n 1)
    1
    (+ (fib (- n 1)) (fib (- n 2)))))

(defn sort-seq []
  (sort (repeat 100000 (rand-int 2000000))))

(defn time-fun [fun]
  (let [start  (.getTime (js/Date.))
        _      (fun)
        end    (.getTime (js/Date.))
        result (- end start)]
    result))

(defn time-it [fun]
  (let [values  (for [i (range 200)] (time-fun fun))]
    (/ (apply + values)
       (count values))))

(defn -main []
  (println &amp;quot;(factorial 5000) \t Avg: &amp;quot; (time-it #(factorial 5000)))
  (println &amp;quot;(fib 20) \t Avg: &amp;quot;         (time-it #(fib 20)))
  (println &amp;quot;(sort-seq) \t Avg: &amp;quot;       (time-it #(sort-seq))))

(set! *main-cli-fn* -main)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Benchmark results:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; node --version
v0.6.12

# simple compiler optimization
&amp;gt; ps eu
%CPU %MEM VSZ    RSS   TTY    STAT START  TIME COMMAND
91.4 20.3 90816  51292 pts/1  Rl+  08:46  0:54 node clojurescript-benchmark-optimization-simple.js

&amp;gt; node clojurescript-benchmark-optimization-simple.js
(factorial 5000) Avg: 64.345
(fib 20)         Avg: 5.575
(sort-seq)       Avg: 7281.975

# advanced compiler optimization
&amp;gt; ps eu
%CPU %MEM VSZ    RSS   TTY    STAT START  TIME COMMAND
99.0 20.9 92200  52776 pts/0  Rl+  07:14  0:44 node clojurescript-benchmark-optimization-advanced.js

&amp;gt; node clojurescript-benchmark-optimization-advanced.js
(factorial 5000) Avg: 54.775
(fib 20)         Avg: 2.77
(sort-seq)       Avg: 6325.71
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So as you can see from output above - ClojureScript can be well suitable for development and scripting on small boards like BeagleBone or Raspberry Pi.
Good speed and better semantics at low prices, I ♥ Clojure and ClojureScript :)&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
